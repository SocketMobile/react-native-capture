"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CaptureArchitectureInfo = exports.BluetoothLEDeviceTypes = void 0;
Object.defineProperty(exports, "CaptureDataSourceFlags", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureDataSourceFlags;
  }
});
Object.defineProperty(exports, "CaptureDataSourceID", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureDataSourceID;
  }
});
Object.defineProperty(exports, "CaptureDataSourceStatus", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureDataSourceStatus;
  }
});
Object.defineProperty(exports, "CaptureDeviceType", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureDeviceType;
  }
});
Object.defineProperty(exports, "CaptureEvent", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureEvent;
  }
});
Object.defineProperty(exports, "CaptureEventIds", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureEventIds;
  }
});
Object.defineProperty(exports, "CaptureEventTypes", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureEventTypes;
  }
});
Object.defineProperty(exports, "CaptureHelper", {
  enumerable: true,
  get: function () {
    return _CaptureHelper.default;
  }
});
Object.defineProperty(exports, "CaptureProperty", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CaptureProperty;
  }
});
Object.defineProperty(exports, "CapturePropertyIds", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CapturePropertyIds;
  }
});
Object.defineProperty(exports, "CapturePropertyTypes", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.CapturePropertyTypes;
  }
});
exports.CaptureSdk = exports.CaptureRn = void 0;
Object.defineProperty(exports, "ConnectBeepConfig", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.ConnectBeepConfig;
  }
});
Object.defineProperty(exports, "ConnectReason", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.ConnectReason;
  }
});
Object.defineProperty(exports, "Counter", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.Counter;
  }
});
Object.defineProperty(exports, "DataConfirmationBeep", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DataConfirmationBeep;
  }
});
Object.defineProperty(exports, "DataConfirmationLed", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DataConfirmationLed;
  }
});
Object.defineProperty(exports, "DataConfirmationMode", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DataConfirmationMode;
  }
});
Object.defineProperty(exports, "DataConfirmationRumble", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DataConfirmationRumble;
  }
});
Object.defineProperty(exports, "DataFormat", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DataFormat;
  }
});
Object.defineProperty(exports, "DeletePairing", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DeletePairing;
  }
});
Object.defineProperty(exports, "DeviceDataAcknowledgment", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.DeviceDataAcknowledgment;
  }
});
Object.defineProperty(exports, "Disconnect", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.Disconnect;
  }
});
Object.defineProperty(exports, "Flash", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.Flash;
  }
});
Object.defineProperty(exports, "JRpcError", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.JRpcError;
  }
});
Object.defineProperty(exports, "LocalDecodeAction", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.LocalDecodeAction;
  }
});
Object.defineProperty(exports, "MonitorDbg", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.MonitorDbg;
  }
});
Object.defineProperty(exports, "PowerState", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.PowerState;
  }
});
Object.defineProperty(exports, "ProfileConfig", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.ProfileConfig;
  }
});
Object.defineProperty(exports, "ProfileSelect", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.ProfileSelect;
  }
});
Object.defineProperty(exports, "RumbleActionType", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.RumbleActionType;
  }
});
Object.defineProperty(exports, "SecurityMode", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.SecurityMode;
  }
});
Object.defineProperty(exports, "SktErrors", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.SktErrors;
  }
});
Object.defineProperty(exports, "SocketCam", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.SocketCam;
  }
});
exports.SocketCamTypes = void 0;
Object.defineProperty(exports, "SocketCamViewContainer", {
  enumerable: true,
  get: function () {
    return _SocketCamViewContainer.default;
  }
});
Object.defineProperty(exports, "SoundActionType", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.SoundActionType;
  }
});
Object.defineProperty(exports, "SoundFrequency", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.SoundFrequency;
  }
});
Object.defineProperty(exports, "StandConfig", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.StandConfig;
  }
});
Object.defineProperty(exports, "StartUpRoleSpp", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.StartUpRoleSpp;
  }
});
Object.defineProperty(exports, "Timer", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.Timer;
  }
});
Object.defineProperty(exports, "Trigger", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.Trigger;
  }
});
Object.defineProperty(exports, "TriggerMode", {
  enumerable: true,
  get: function () {
    return _socketmobileCapturejs.TriggerMode;
  }
});
var _reactNative = require("react-native");
var _NativeCaptureSdk = _interopRequireDefault(require("./NativeCaptureSdk"));
var _SocketCamViewContainer = _interopRequireDefault(require("./components/SocketCamViewContainer"));
var _socketmobileCapturejs = require("socketmobile-capturejs");
var _CaptureHelper = _interopRequireDefault(require("./CaptureHelper"));
function _interopRequireDefault(e) { return e && e.__esModule ? e : { default: e }; }
const LINKING_ERROR = `The package 'react-native-capture' doesn't seem to be linked. Make sure: \n\n` + _reactNative.Platform.select({
  ios: "- You have run 'pod install'\n",
  default: ''
}) + '- You rebuilt the app after installing the package\n' + '- You are not using Expo Go\n';

// Use TurboModule for new architecture, fallback to legacy for old architecture
const CaptureSdk = exports.CaptureSdk = (() => {
  // Try to get TurboModule first (new architecture)
  if (_NativeCaptureSdk.default) {
    console.log('CaptureSdk: Using NEW ARCHITECTURE (TurboModule) ✅');
    return _NativeCaptureSdk.default;
  }

  // Fallback to legacy bridge module (old architecture)
  if (_reactNative.NativeModules.CaptureSdk) {
    console.log('⚠️  CaptureSdk: Using LEGACY ARCHITECTURE (Bridge)');
    return _reactNative.NativeModules.CaptureSdk;
  }

  // If neither is available, return proxy that throws linking error
  console.error('CaptureSdk: No module found - check linking');
  return new Proxy({}, {
    get() {
      throw new Error(LINKING_ERROR);
    }
  });
})();

// exporting React Native Specific AppInfo interface in order to use the new properties in a typestrict way

const noLogger = {
  log: () => {},
  error: () => {}
};
const SocketCamTypes = exports.SocketCamTypes = [_socketmobileCapturejs.CaptureDeviceType.SocketCamC820, _socketmobileCapturejs.CaptureDeviceType.SocketCamC860];
const BluetoothLEDeviceTypes = exports.BluetoothLEDeviceTypes = [_socketmobileCapturejs.CaptureDeviceType.ScannerS320, _socketmobileCapturejs.CaptureDeviceType.ScannerS370, _socketmobileCapturejs.CaptureDeviceType.ScannerS550];
const onCaptureEvent = e => {
  // maybe need to access handle here but this one doesn't get called in Android.
  console.log('index onCaptureEvent <= ', e);
  const event = JSON.parse(e.toString());
  if (CaptureSdk.onNotification) {
    CaptureSdk.onNotification(event);
  }
};

// Create event emitter with proper fallback handling
let captureEventEmitter;
let subscription;
try {
  // For new architecture, events are handled differently
  if (_NativeCaptureSdk.default) {
    captureEventEmitter = new _reactNative.NativeEventEmitter(CaptureSdk);
  } else {
    captureEventEmitter = new _reactNative.NativeEventEmitter(CaptureSdk);
  }
  subscription = captureEventEmitter.addListener('onCaptureEvent', onCaptureEvent);
} catch (error) {
  console.warn('Failed to create event emitter for CaptureSdk:', error);
  // Create a dummy subscription that can be safely removed
  subscription = {
    remove: () => {}
  };
}

// Extend CaptureSdk with legacy compatibility methods
if (!CaptureSdk.open) {
  CaptureSdk.open = (host, notification) => {
    CaptureSdk.onNotification = notification;
    return CaptureSdk.openTransport(host).then(result => result.transport);
  };
}
if (!CaptureSdk.send) {
  CaptureSdk.send = (handle, jsonRpc) => {
    console.log('=> ', jsonRpc);
    return CaptureSdk.sendTransport(handle, JSON.stringify(jsonRpc)).then(response => {
      console.log('<= ', response);
      return JSON.parse(response.toString());
    });
  };
}
if (!CaptureSdk.close) {
  CaptureSdk.close = handle => {
    subscription.remove();
    return CaptureSdk.closeTransport(handle);
  };
}
const getOptions = (platform, options, logger) => {
  const final = options || {};
  if (platform.OS === 'ios') {
    // Set logger if CaptureSdk supports it (legacy compatibility)
    if (CaptureSdk && typeof CaptureSdk === 'object') {
      CaptureSdk.logger = logger || noLogger;
    }
    final.transport = CaptureSdk;
  } else {
    // Start capture service for Android
    if (CaptureSdk.startCaptureService) {
      CaptureSdk.startCaptureService();
    }
  }
  return final;
};
class CaptureRn extends _socketmobileCapturejs.Capture {
  constructor(logger) {
    super(logger);
    this.logger = logger;
  }
  openForAndroid(tries, appInfo, callback, options) {
    return new Promise((resolve, reject) => {
      let interval;
      const openRetry = () => {
        clearInterval(interval);
        super.open(appInfo, callback, options).then(result => resolve(result)).catch(err => {
          console.log('android retry error: ', err);
          if (tries > 0) {
            tries -= 1;
            interval = setInterval(openRetry, 250);
          } else {
            reject(err);
          }
        });
      };
      interval = setInterval(openRetry, 250);
    });
  }
  open(appInfo, callback, options) {
    const finalOptions = getOptions(_reactNative.Platform, options, this.logger);
    if (_reactNative.Platform.OS === 'android') {
      let newAppInfo = genAppInfo(appInfo, true);
      return this.openForAndroid(10, newAppInfo, callback, options);
    }
    let newAppInfo = genAppInfo(appInfo, false);
    return super.open(newAppInfo, callback, finalOptions);
  }
}
exports.CaptureRn = CaptureRn;
const genAppInfo = (appInfo, isAndroid) => {
  const appId = isAndroid ? appInfo.appIdAndroid : appInfo.appIdIos;
  const appKey = isAndroid ? appInfo.appKeyAndroid : appInfo.appKeyIos;
  return {
    ...appInfo,
    appId: appId || appInfo.appId,
    appKey: appKey || appInfo.appKey
  };
};

// Architecture detection utility
const CaptureArchitectureInfo = exports.CaptureArchitectureInfo = {
  isUsingNewArchitecture: () => {
    return !!_NativeCaptureSdk.default;
  },
  isUsingTurboModule: () => {
    return !!_NativeCaptureSdk.default;
  },
  getArchitectureInfo: () => {
    const isNewArch = !!_NativeCaptureSdk.default;
    const hasLegacyModule = !!_reactNative.NativeModules.CaptureSdk;
    return {
      architecture: isNewArch ? 'new' : 'legacy',
      usingTurboModule: isNewArch,
      usingBridge: !isNewArch && hasLegacyModule,
      moduleType: isNewArch ? 'TurboModule' : 'Bridge',
      platform: _reactNative.Platform.OS,
      reactNativeVersion: _reactNative.Platform.constants.reactNativeVersion
    };
  },
  logArchitectureInfo: () => {
    const info = CaptureArchitectureInfo.getArchitectureInfo();
    console.log('CaptureSdk Architecture Info:', info);
    return info;
  }
};

// interface to more easily identify device captures from root captures
// and allow device captures to contain device info useful in UI, such as
// identifying different devices in a list, rendering device names, etc.
//# sourceMappingURL=index.js.map